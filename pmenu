#!/usr/bin/env python
import os
import sys
import re
import signal
import difflib
import curses
import argparse
import fileinput

required_version = (3, 3)
if sys.version_info < required_version:
    sys.exit("Python {}.{} or newer is required.".format(*required_version))

query_text = ''
input_items = sys.stdin.read().splitlines()
filtered_items = []
selection_index = 0

def signal_handler(signum, frame):
    sys.exit(130)
signal.signal(signal.SIGINT, signal_handler)

def filter_items():
    global filtered_items

    filtered_items = []
    query_text_regex = re.compile(r".*".join(re.escape(c) for c in query_text), flags=re.I)
    for input_item in input_items:
        if query_text and not query_text_regex.search(input_item):
            continue

        if query_text:
            item_score = difflib.SequenceMatcher(None, input_item, query_text).quick_ratio()
        else:
            item_score = 1
        filtered_items.append((input_item, item_score))

    if query_text:
        filtered_items = sorted(filtered_items, key=lambda filtered_item: filtered_item[1], reverse=True)

def redraw(screen):
    screen.erase()

    for i, filtered_item in enumerate(filtered_items[:curses.LINES - 1]):
        item_attr = curses.A_REVERSE if i == selection_index else curses.A_NORMAL
        screen.insstr(i + 1, 0, filtered_item[0][:curses.COLS], item_attr)

    command_text = args.prompt + query_text
    command_text_offset = len(command_text) - (curses.COLS - 1)
    if command_text_offset < 0:
        command_text_offset = 0
    screen.addstr(0, 0, command_text[command_text_offset:])

    screen.refresh()

def change_selection(new_selection_index):
    global selection_index

    if new_selection_index < 0 or new_selection_index >= min(len(filtered_items), curses.LINES - 1):
        return

    selection_index = new_selection_index

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-n', '--name', help="MRU list name")
    parser.add_argument('-p', '--prompt', default="> ", help="prompt text")

    return parser.parse_args()

def get_mru_path():
    if not args.name:
        return

    cache_dir = os.environ.get('XDG_CACHE_HOME', os.path.join(os.path.expanduser('~'), '.cache'))
    mru_dir = os.path.join(cache_dir, 'pmenu')
    os.makedirs(mru_dir, exist_ok=True)

    return os.path.join(mru_dir, args.name)

def process_mru_items():
    global input_items

    if not mru_path or not os.path.exists(mru_path):
        return

    cache_items = open(mru_path).read().splitlines()
    cache_items = [i for i in cache_items if i in input_items]
    cache_items.reverse()

    input_items = cache_items + [i for i in input_items if i not in cache_items]

def add_mru_item(mru_item):
    if not mru_path:
        return

    if os.path.exists(mru_path):
        with fileinput.input(mru_path, inplace=True) as cache_file:
            for cache_line in cache_file:
                cache_item = cache_line.rstrip("\n\r")
                if cache_item != mru_item:
                    print(cache_item)

    with open(mru_path, 'a') as cache_file:
        cache_file.write(mru_item)

def main(screen):
    global query_text, selection_index

    filter_items()
    redraw(screen)

    while True:
        char = screen.get_wch()
        keyname = curses.keyname(char).decode('utf8') if isinstance(char, int) else None
        keyname_string = curses.keyname(ord(char)).decode('utf8') if isinstance(char, str) else None
        if char == curses.KEY_RESIZE:
            y, x = screen.getmaxyx()
            curses.resizeterm(y, x)
            selection_index = 0
            redraw(screen)
            continue
        elif char == '\b' or keyname == 'KEY_BACKSPACE':
            query_text = query_text[:-1]
        elif isinstance(char, int):
            continue
        elif char == '\n':
            return
        elif keyname_string == '^G':
            sys.exit(130)
        elif keyname_string == '^U':
            query_text = ''
        elif keyname_string == '^W':
            query_text = re.sub(r"\w*[^\w]*$", '', query_text)
        elif keyname_string == '^N':
            change_selection(selection_index + 1)
            redraw(screen)
            continue
        elif keyname_string == '^P':
            change_selection(selection_index - 1)
            redraw(screen)
            continue
        elif len(keyname_string) == 2 and keyname_string[0] == '^':
            continue
        else:
            query_text += char

        selection_index = 0

        filter_items()
        redraw(screen)

def redirect_stdio(func):
    try:
        prev_stdin = os.dup(0)
        prev_stdout = os.dup(1)
        stdin = open("/dev/tty")
        stdout = open("/dev/tty", 'w')
        os.dup2(stdin.fileno(), 0)
        os.dup2(stdout.fileno(), 1)

        func()
    finally:
        os.dup2(prev_stdin, 0)
        os.dup2(prev_stdout, 1)

def curses_wrapper(func):
    is_vim = os.environ.get('VIM')
    try:
        screen = curses.initscr()
        curses.noecho()
        curses.cbreak()
        screen.keypad(1)
        try:
            curses.start_color()
        except:
            pass

        if is_vim:
            curses.curs_set(1)

        func(screen)
    finally:
        if 'screen' in locals():
            screen.keypad(0)
            curses.echo()
            curses.nocbreak()
            if not is_vim:
                curses.endwin()

if __name__ == '__main__':
    args = parse_args()
    mru_path = get_mru_path()
    process_mru_items()

    redirect_stdio(lambda: curses_wrapper(main))

    if selection_index < len(filtered_items):
        selected_item = filtered_items[selection_index][0]
        add_mru_item(selected_item)

        print(selected_item)
    else:
        print(query_text)
