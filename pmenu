#!/usr/bin/env python
import os
import sys
import re
import signal
import difflib
import curses
import argparse
import fileinput

required_version = (3, 3)
if sys.version_info < required_version:
    sys.exit("Python {}.{} or newer is required.".format(*required_version))

signal.signal(signal.SIGINT, lambda *args: sys.exit(130))

def get_args():
    parser = argparse.ArgumentParser(usage="pipe menu items to stdin or pass them with as positional arguments")
    parser.add_argument('item', nargs='*', help="menu item text")
    parser.add_argument('-n', '--name', help="name of the usage cache")
    parser.add_argument('-p', '--prompt', help="prompt text")

    args = parser.parse_args()
    if args.prompt is None:
        args.prompt = "> "
        if args.name:
            args.prompt = args.name + args.prompt

    return args

def get_mru_path():
    if not args.name:
        return

    cache_dir = os.environ.get('XDG_CACHE_HOME', os.path.join(os.path.expanduser('~'), '.cache'))
    mru_dir = os.path.join(cache_dir, 'pmenu')
    os.makedirs(mru_dir, exist_ok=True)

    return os.path.join(mru_dir, args.name)

def get_input_items():
    input_item_texts = []
    if not sys.stdin.isatty():
        input_item_texts += sys.stdin.read().splitlines()
    input_item_texts += args.item

    if mru_path and os.path.exists(mru_path):
        mru_item_texts = open(mru_path).read().splitlines()
        mru_items = [(i, 1, True) for i in mru_item_texts if i in input_item_texts]
        mru_items.reverse()

        input_items = mru_items + [(i, 0, False) for i in input_item_texts if i not in mru_item_texts]
    else:
        input_items = [(i, 0, False) for i in input_item_texts]

    return input_items

def redirect_stdio(func):
    try:
        prev_stdin = os.dup(0)
        prev_stdout = os.dup(1)
        stdin = open("/dev/tty")
        stdout = open("/dev/tty", 'w')
        os.dup2(stdin.fileno(), 0)
        os.dup2(stdout.fileno(), 1)

        return func()
    finally:
        os.dup2(prev_stdin, 0)
        os.dup2(prev_stdout, 1)

def curses_wrapper(func):
    is_vim = os.environ.get('VIM')
    try:
        screen = curses.initscr()
        curses.noecho()
        curses.cbreak()
        screen.keypad(1)
        try:
            curses.start_color()
        except:
            pass

        if is_vim:
            curses.curs_set(1)

        return func(screen)
    finally:
        if 'screen' in locals():
            screen.keypad(0)
            curses.echo()
            curses.nocbreak()
            if not is_vim:
                curses.endwin()

def get_filtered_items():
    filtered_items = []
    query_text_regex = re.compile(r".*".join(re.escape(c) for c in query_text), flags=re.I)
    for input_item_text, input_item_score, is_mru_item in input_items:
        if query_text and not query_text_regex.search(input_item_text):
            continue

        if query_text and not is_mru_item:
            input_item_score += difflib.SequenceMatcher(None, input_item_text, query_text).quick_ratio()
        filtered_items.append((input_item_text, input_item_score))

    if query_text:
        filtered_items = sorted(filtered_items, key=lambda filtered_item: filtered_item[1], reverse=True)

    return filtered_items

def redraw(screen):
    screen.erase()

    for i, filtered_item in enumerate(filtered_items[:curses.LINES - 1]):
        item_attr = curses.A_REVERSE if i == selection_index else curses.A_NORMAL
        screen.insstr(i + 1, 0, filtered_item[0][:curses.COLS], item_attr)

    top_line_text = args.prompt + query_text
    top_line_offset = len(top_line_text) - (curses.COLS - 1)
    if top_line_offset < 0:
        top_line_offset = 0
    screen.addstr(0, 0, top_line_text[top_line_offset:])

    screen.refresh()

def main(screen):
    global query_text, selection_index, filtered_items

    query_text = ''
    selection_index = 0
    filtered_items = get_filtered_items()
    redraw(screen)

    while True:

        char = screen.get_wch()
        keyname = curses.keyname(char).decode('utf8') if isinstance(char, int) else None
        keyname_string = curses.keyname(ord(char)).decode('utf8') if isinstance(char, str) else None

        if char == curses.KEY_RESIZE:
            selection_index = 0
            curses.resizeterm(*screen.getmaxyx())
            redraw(screen)

            continue

        elif char == '\b' or keyname == 'KEY_BACKSPACE':
            query_text = query_text[:-1]

        elif isinstance(char, int):
            continue

        elif char == '\n':
            break

        elif keyname_string == '^G':
            sys.exit(130)

        elif keyname_string == '^U':
            query_text = ''

        elif keyname_string == '^W':
            query_text = re.sub(r"\w*[^\w]*$", '', query_text)

        elif keyname_string == '^N':
            if selection_index < min(len(filtered_items), curses.LINES - 1) - 1:
                selection_index += 1
            redraw(screen)

            continue

        elif keyname_string == '^P':
            if selection_index > 0:
                selection_index -= 1
            redraw(screen)

            continue

        elif len(keyname_string) == 2 and keyname_string[0] == '^':
            continue

        else:
            query_text += char

        selection_index = 0
        filtered_items = get_filtered_items()
        redraw(screen)

    if len(filtered_items):
        return True, filtered_items[selection_index][0]
    else:
        return False, query_text

def add_mru_text(mru_text):
    if not mru_path:
        return

    if os.path.exists(mru_path):
        with fileinput.input(mru_path, inplace=True) as mru_file:
            for mru_line in mru_file:
                mru_line_text = mru_line.rstrip("\n\r") 
                if mru_line_text != mru_text:
                    print(mru_line_text)

    with open(mru_path, 'a') as mru_file:
        mru_file.write(mru_text)

if __name__ == '__main__':
    args = get_args()
    mru_path = get_mru_path()
    input_items = get_input_items()

    is_existing_item, selection_text = redirect_stdio(lambda: curses_wrapper(main))
    if is_existing_item:
        add_mru_text(selection_text)
    print(selection_text)
