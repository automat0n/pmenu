#!/usr/bin/env python
import os
import sys
import re
import signal
import curses
import argparse
import fileinput

required_version = (3, 3)
if sys.version_info < required_version:
    sys.exit("Python {}.{} or newer is required.".format(*required_version))

signal.signal(signal.SIGINT, lambda *args: sys.exit(130))

def get_args():
    parser = argparse.ArgumentParser(usage="pipe menu items to stdin or pass them with as positional arguments")
    parser.add_argument('item', nargs='*', help="menu item text")
    parser.add_argument('-n', '--name', help="name of the usage cache")
    parser.add_argument('-p', '--prompt', help="prompt text")

    args = parser.parse_args()
    if args.prompt is None:
        args.prompt = "> "
        if args.name:
            args.prompt = args.name + args.prompt

    return args

def get_mru_path():
    if not args.name:
        return

    cache_dir = os.environ.get('XDG_CACHE_HOME', os.path.join(os.path.expanduser('~'), '.cache'))
    mru_dir = os.path.join(cache_dir, 'pmenu')
    os.makedirs(mru_dir, exist_ok=True)

    return os.path.join(mru_dir, args.name)

def get_input_items():
    input_items = []
    if not sys.stdin.isatty():
        input_items += sys.stdin.read().splitlines()
    input_items += args.item

    if mru_path and os.path.exists(mru_path):
        mru_items = open(mru_path).read().splitlines()
        mru_items = [i for i in mru_items if i in input_items]
        mru_items.reverse()

        input_items = mru_items + [i for i in input_items if i not in mru_items]

    return input_items

def redirect_stdio(func):
    try:
        prev_stdin = os.dup(0)
        prev_stdout = os.dup(1)
        stdin = open("/dev/tty")
        stdout = open("/dev/tty", 'w')
        os.dup2(stdin.fileno(), 0)
        os.dup2(stdout.fileno(), 1)

        return func()
    finally:
        os.dup2(prev_stdin, 0)
        os.dup2(prev_stdout, 1)

def curses_wrapper(func):
    if 'ESCDELAY' not in os.environ:
        os.environ['ESCDELAY'] = '0'

    is_vim = os.environ.get('VIM')
    try:
        screen = curses.initscr()
        curses.noecho()
        curses.cbreak()
        screen.keypad(1)
        try:
            curses.start_color()
        except:
            pass

        if is_vim:
            curses.curs_set(1)

        return func(screen)
    finally:
        if 'screen' in locals():
            screen.keypad(0)
            curses.echo()
            curses.nocbreak()
            if not is_vim:
                curses.endwin()

def get_filtered_items():
    if not query_text:
        filtered_items = input_items
    else:
        query_words = re.split(r"\s+", query_text)
        query_regexes = [re.compile(re.escape(i), re.I) for i in query_words if i]

        exact_matched_items = []
        prefix_matched_items = []
        substring_matched_items = []
        for input_item in input_items:
            is_matched = True
            first_match = None
            for i, query_regex in enumerate(query_regexes):
                match = re.search(query_regex, input_item)
                if not match:
                    is_matched = False
                    break
                elif not i:
                    first_match = match.group(0)
            if not is_matched:
                continue

            if input_item == first_match:
                exact_matched_items.append(input_item)
            elif not input_item.find(first_match):
                prefix_matched_items.append(input_item)
            else:
                substring_matched_items.append(input_item)
        filtered_items = exact_matched_items + prefix_matched_items + substring_matched_items

    return filtered_items

def redraw(screen):
    screen.erase()

    for i, filtered_item in enumerate(filtered_items[:curses.LINES - 1]):
        item_attr = curses.A_REVERSE if i == selection_index else curses.A_NORMAL
        screen.insstr(i + 1, 0, filtered_item[:curses.COLS], item_attr)

    top_line_text = args.prompt + query_text
    top_line_offset = len(top_line_text) - (curses.COLS - 1)
    if top_line_offset < 0:
        top_line_offset = 0
    screen.addstr(0, 0, top_line_text[top_line_offset:])

    screen.refresh()

def main(screen):
    global query_text, selection_index, filtered_items

    query_text = ''
    selection_index = 0
    filtered_items = get_filtered_items()
    redraw(screen)

    while True:
        char = screen.get_wch()
        keyname = curses.keyname(char).decode('utf8') if isinstance(char, int) else None
        keyname_string = curses.keyname(ord(char)).decode('utf8') if isinstance(char, str) else None

        if char == curses.KEY_RESIZE:
            selection_index = 0
            curses.resizeterm(*screen.getmaxyx())
            redraw(screen)

            continue

        elif char == '\b' or keyname == 'KEY_BACKSPACE':
            query_text = query_text[:-1]

        elif keyname == 'KEY_DOWN' or keyname_string == '^N':
            if selection_index < min(len(filtered_items), curses.LINES - 1) - 1:
                selection_index += 1
            redraw(screen)

            continue

        elif keyname == 'KEY_UP' or keyname_string == '^P':
            if selection_index > 0:
                selection_index -= 1
            redraw(screen)

            continue

        elif keyname_string in ['^[', '^G']:
            sys.exit(130)

        elif keyname_string == '^U':
            query_text = ''

        elif keyname_string == '^W':
            query_text = re.sub(r"\w*[^\w]*$", '', query_text)

        elif char == '\n':
            break

        elif char == '\t':
            if filtered_items:
                query_text = filtered_items[0]

        elif isinstance(char, int):
            continue

        elif len(keyname_string) > 1 and keyname_string[0] == '^':
            continue

        else:
            query_text += char

        selection_index = 0
        filtered_items = get_filtered_items()
        redraw(screen)

    if filtered_items:
        return True, filtered_items[selection_index]
    else:
        return False, query_text

def add_mru_text(mru_text):
    if not mru_path:
        return

    if os.path.exists(mru_path):
        with fileinput.input(mru_path, inplace=True) as mru_file:
            for mru_line in mru_file:
                mru_line_text = mru_line.rstrip("\n\r") 
                if mru_line_text != mru_text:
                    print(mru_line_text)

    with open(mru_path, 'a') as mru_file:
        mru_file.write(mru_text)

if __name__ == '__main__':
    args = get_args()
    mru_path = get_mru_path()
    input_items = get_input_items()

    is_existing_item, selection_text = redirect_stdio(lambda: curses_wrapper(main))
    if is_existing_item:
        add_mru_text(selection_text)
    print(selection_text)
